파일시스템의 부적절성 :
1 - 동시성의 부재
누군가가 파일을 열고 있을 때, 또 다른 누군가가 네트워크를 통한 엑세스를 했을 때 - (ONLY READABLE)읽기 전용 상태로 열 수는 있지만 쓸 수는 없음
또한 누군가가 파일을 수정할 때, 또 다른 누군가가 읽는 도중 실시간적 반영이 되지 않음

2 - 정합성의 부재
관리에 있어 힘듬(무결성).

즉 파일시스템으로 데이터를 관리할 때 동시성, 정합성의 문제가 자주 발생할 수 있음. 특히 엑셀로 자주 비교함.

어느 저장해야할 대상은 인스턴스가 된다. 외래 키는 중복값을 판별하기 위해 사용한다.
칼럼 이름 = 변수명, 데이터타입 = 변수 타입.

* = all
모두 라는 뜻과 비슷함.

데이터타입 옆의 (괄호) 내부에 들어가는 값은 길이값임.


엔티티

테이블 명세서

데이터베이스 공부는
문제를 입력하고 복습하면 됨.

DISTINCT 부분엔 조건문이 들어감. 어느 정도의 서술문이 포함되어있을수도 있음. 예를 들어
이름이 홍길동이면 조회해줘~와 같은형식임. 그러나 DISTINCT는 ~을 제외하고 라는 뜻임. 즉 중복에 대한 처리.
튜플(행) 에 따른 결과의 중복처리를 해줌.
만약 DISTINCT 부분에 쉼표로 또 다른 조건을 추가할 경우
행 집합 기준으로 중복처리를 수행하는 DISTINCT는 위 조건에 맞추어 처리함.
만약 유일값이 들어가면 모든 번호를 출력하게 된다는 것임(EX 학번)

AS 키워드를 추가하는 방식은 별명을 부여할 때 사용됨. 이때, 공백이나 특수문자가 들어갈 경우에,
스트링 형식과 같은 "" 을 이용해서 함. 별칭은 사실 COUNT나 AVG와 같은 메서드? 를 혼용할 때 무엇을 셌는지, 무엇을 집계하여 평균을 냈는지
에 대한 메모 형식의 느낌을 위해 단일적인 이름을 붙이는 데에 많이 사용된다.

합성 연산자
CONCATENATION 연산자 ||

산술 연산자 사용 가능.
숫자 또는 날짜 타입!!!! 에 사용 가능하다. 예를 들어, 날짜에서 날짜를 뺐을 경우 차이가 발생함.

논리연산자 AND OR NOT 으로 사용하기.

GROUP BY 는 쉽게 생각해서 ~~별 ~~ 을 조회하는 형식임.

키워드는 보통 대문자로 사용.(예악어)


불필요한 형태의 공간 낭비를 제어한다. 

만약 데이터베이스 설계가 잘 안된다면 정말 괴로운 수준으로까지 악화됨.
반대로 잘 된다면 엄청 로직구현이 편안해짐

데이터타입
1 사용자 정의 타입
2 내장 
- 스칼라(CHAR< NCHAR< VARCHAR() < NUMBER() < RAW(N) < BLOB < LONG < ROWID 등등...
고정과 비고정(탄력적 증가, 가변) = char, varchar 
항상 길이가 같을 경우에는 char도 가능하지만, varchar에서만 가능

ROWID = list 기준으로, select 했을 때 학생 한명이 1 행임. 즉 1 객체 = 1 행 
이에 따른 각각의 고유 id가 존재하게 되는데 이것이 로우아이디.

CLOB = 대용량의 텍스트 데이터를 저장하기 위한 데이터 타입(텍스트 타입)
BLOB = 바이너리 데이터를 저장하게 되는 데이터 타입(텍스트 타입) 메모장을 통해 읽을수 있느냐 없느냐 정도의 차이.

초기값은 따로 부여하지 않으면 대부분 null이 됨.
데이터 길이보다 더 큰 데이터가 입력될 경우 오류가 발생한다. 

NUMBER 타입에 대한 계산의 부정확성은 DOUBLE과 달리 업슴.

DATE 타입은 7바이트. 인트보다 작다! 오히려 좋아서 메모리걱정안하고 써도댐

SYSDATE = 현재날짜와 시간을 반환하는 함수 
시, 분, 초 값 반환

LOB 데이터 타입 = 텍스트, 그래픽, 이미지, 동영상, 사운드 등과 같이 구조화되지 않은 대용량의 텍스트나 멀티미디어 데이터를
저장하기 위한 데이터타입 

시스템 구축이란 하드웨어부터 서버, 프로그램까지 하는 것들임. 결정들. 이럴 때 하드웨어적인것도 당연히 중요하지만
소프트웨어적 측면도 당연하게도 중요함. 
언제나 가장 비용적인 측면은 데이터베이스임. 

보통 CLOB 말고는 LOB 타입을 잘 사용하지 않음.

로우아이디는 실행 할 때 나옴. 자바에서의 this와 비슷함. 

Pseudo COLOMN은 따로 보이지 않지만 사용이 가능한 것. 
DESCRIBE 를 통해 볼 수는 없지만 SEQUENCE 를 자주 사용함
HIERARCHICAL QUERIES 계층형 쿼리
(재귀적 형태의 호출)

ROWNUM 같은 경우는 QUERY에 의해 추출된 각 행에 부여된 일렵번호
ROWNUM은 SELECT 절에서 정해지는데, 먼저 실행되는 WHERE 절에서 ROWNUM 조건으로 사용이 불가하기 때문. 
즉 ROW넘은 몇 건을 지정하는 것이지 몇번째 건을 지정하는 것이 아님. 

TIMESTAMP WITH LOCAL TIME ZONE

DUAL 테이블은 자동 생성되는 계산용 목적으로 사용되는 테이블.


WHERE절 -- 문법적으로 

테이블에 저장된 데이터 중 원하는 데이터만 선택적으로 검색하는 기능 
WHERE 절의 조건문은 칼럼 이름, 연산자, 상수, 산술 표현식을 결합하여 다양한 형태로 표현 가능 
WHERE 절에서 사용하는 데이터 타입은 문자, 숫자, 날짜 타입 사용 가능 
문자는 날짜 타입의 상수 값은 작은 따옴표 '' 로 묶어서 표현하고 숫자로 그대로 사용. 

우리가 일반적으로 알고 있는 동일 연산자 == 가 아닌 
그냥 = 을 이용해서 값을 비교 가능(그냥 등호가 아닌) 

between = 범위에 따른 구분연산(and와 같은 구분연산을 이용한 듯한 것을 반환)
IN (A, B, C) = 특정 칼럼의 값이 A B C 중 하나라도 있으면 참(OR 연산 사용한 것 같은 값을 반환)

like = 문자 패턴과 부분적으로 일치하면 참(startwith, charat같은것 사용)
LIKE 뒤에 들어오는 문자열 부분의 특수문자는 _와 $ 사용 

이스케이프 문자 = 특정 능력을 지닌 문자열을 텍스트로서 활용하기 위해 

NULL = 미확인 값, 적용되지 않은 값
NULL 은 특수값이며 다른 값으로 변경했을 경우 문제가 발생할 수 있다. 
NULL 값은 연산이 불가하다. 정확히 말하자면 NULL과 어떤 수를 계산하면 NULL이 된다. 
null 값이냐 아니냐 = isnull, is not null
UNKNOWN 값은 논리연산에서 FALSE 로 처리한다. 그러므로 NOTNULL 명령어만 주로 사용

의외로 SQL 자체연산자가 연산자 우선순위가 높은 편이다. 

NVL 
NVL2 = (어떤 값이, NULL이 아닐때 출력부, NULL일때 출력부)



중간에 커밋할때 = 스냅샷 찍기와 같음. 


테이블을 구성하는 행집합에 대해 테이블의 부분 집합을 결과로 반환하는 연산자 
합병 가능 : 집합 연산의 대상이 되는 두 테이블의 칼럼수가 같고, 데이터 타입이 동일해야 함

정렬
- 문자 값은 알파벳순으로 출력되고, 한글은 가나다순으로 출력된다.
- 날짜의 경우 옛날이 먼저.
- ORDER BY 칼럼이나 표현식을 기준으로 출력 결과를 정렬할 때 사용
- ASC 오름차순으로 정렬(어센딩)
- DSC 내림차순으로 정렬(디센딩)

NULL 값은 오름차순에선 내림차순에선


SQL 핫무는 칼럽의 값이나 데이터 타입의 변경이 이루어지는 경우
단일 행 함수, 복수 행 함수가 존재한다.
단일 행 = 단일 행에 적용되고, 단일 행을 변경하기 때문에 단일 행 함수이다. NVL, CONCAT 같은 경우가 있다. 
함수명 ( 칼럼 | 표현, [파라미터들])
복수 행 = 집계 함수, 복수개의 행들 

기능만 하는 키워드는 프로시져라고 부름.
함수는 반드시 데이터를 넣어줘야 함. 언제나 반환값도 있어야 함. 이것이 필수조건. 다른 언어와 다르지 않음.


라우터(공유기, 분배기) 가 공유 ip를 가지고 있다. 디코 사람입니까 질문도 그래서 나오는 것(공유ip라서)
핑을 찍었을 때 나오는 숫자는 도메인 값.
네트워크를 통해 전달되는 값은 컴퓨터의 공간에 담긴. 여기서 이 공간에 들어가기 위한 구문은 다양함.

GET = 함수
SET = 프로시져

문자를 대상으로 하는 함수는 문자 함수이다.
LENGTH.BIT = 몇 바이트를 차지하고 있는지?

SUBSTRING = ~에서부터 ~까지
INSTR = INDEXOF

LPAD = 왼쪽 정렬 후 오른쪽으로 지정 문자 삽입
RPAD = 오른쪽 정렬 후 오른쪽으로 지정 문자

삽입
LSTRING = 왼쪽 지정 문제의 위치를 삭제, 대부분 마스킹 할때 사용(덮는 용도), 칸 띄우기에도 자주 사용됨.
서브스트링에서 시작부분이 -가 있을경우 뒤에서부터 계산함.

일반적인 INDEXOF 에서 조금 다른 느낌의 INSTR ( 문자열, N부터, M번째)

하고자 하는 일이 어려울 때는 언제나 분할적인 작업이 필요하다.

LTRIM, RTRIM = 특정 문자를 삭제할 때

숫자 함수 = 숫자 데이터를 처리하기 위한 함수

ROUND(반올림 할 숫자, 반올림의 기준 = 0), TRUNC(절삭, 소수점 버리기, 버림점의 기준), MOD(M, %N), 
CEIL(지정한 값보다 큰 수 중 가장 작은 정수), FLOOR(지정한 값보다 작은 수중 가장 큰 정수)

MONTH_BETWEEN = 날짜와 날짜 사이의 개월을 계산한다. 
ADD_MONTHS = 날짜 타입에 개월을 더한다.
NEXT_DAY = 날짜 후에 첫 요일의 날짜를 더한다. 

LAST_DAY 함수는 해당 날짜가 속한 달의 마지막 날짜를 반환하는 함수 
NEXT_DAY 함수는 

거의 모든 테이블은 시간 관련 정보를 담은 DATE 타입의 칼럼을 하나정도는 가지고 있다.
TRUNC 함수는 무조건 당일을 출력하게 할 수 있다.
ROUND 함수는 시간정보에 따라 다른 결과를 도출해낸다. 	

데이터 타입의 변화는 숫자나 날짜 타입을 문자와 함께 결합하거나 양식에 저장해주는 것이라고 생각한다. 

묵시적 데이터 타입 변환은 정확한 연산을 위하여 오라클에서 데이터 타입을 내부적으로 변환하는 경우이다. 

SQL에선 컴파일 대신 PARSSING 이라는 작업을 진행한다.  

TEXT = 결과와 함께 출력할 문자열을 인용 부호로 표시
TH = 서수로 표시
SP = 숫자를 영문으로 표기

9 - 한자리의 숫자 표시
0 - 앞부분을 0으로 표시
$ - 달러 기호를 앞에 표시
. - 소수점을 표시
, - 특정위치에 , 표시


TO-NUMBER(CHAR) - 
NULLIF 함수 - 두 개의 표현식을 비교하여 값이 동일하면 NULL, 다르면 표현식의 값을 반환한다.
COALESCE 함수 

DECODE 함수 - DECODE 함수는 기존 프로그래밍 언어에서 IF문이나 CASE 문으로 표현되는 복잡한 알고리즘을 하나의 SQL 명령문으로 간단하게 표현할 수 있는 유용한 기능
DECODE 함수는 프로그래밍 언어의 SWITCH 와 비슷함 
DECODE(SWTICH 변수 , 얘랑 같으면, 결과)

CASE 함수는 DECODE 함수의 기능을 확장한 함수
CASE는 보통 함수라기보다 구문이라고 하기는 함
DECODE 함수는 표현식 또는 칼럼 값이 = 비교를통해 조건과 일치하는 경우에만 다른 값으로 대치할 수 있지만, 
CASE 함수에서는 산술연산, 관계연산, 논리연산과 같은 다양한 비교가 가능하다. 
CASE 같은 경우는 들여쓰기가 매우 중요하다.

GROUP 함수란?
테이블의 전체 행을 하나 이상의 컬럼을 기준으로 그룹화하여 그룹별로 결과를 출력하는 함수.
그룹함수는 통계적인 결과를 출력하는데 자주 사용
조건이 있을 경우 HAVING 은 사용해야 함. 
어떤 칼럼을 사용해야 할지에 대한 예상치가 매우 중요함.
특히 통계쪽에서 활용할 때 무궁무진하게 지나감. 

카운트 함수 

GROUP BY 함수 : 특정 칼럼 값을 기준으로 테이블의 전체 행을 그룹별로 나누기 위한 절, 
예를 들어 교수 테이블에서 소속 학과별이나 직급별로 평균 급여를 구하는 경우
GROUPBY는 무조건 WHERE 다음에 함.
SELECT 절에서 나열된 칼럼 이름이나 표현식은 GROUP BY 절에서 반드시 명시, 즉 그룹 바이를 하였을 때 행의 변동이 발생하고, 그룹에 대한 묶음의 예상치를 계산하는것이 매우 중요

다중 칼럼을 이용한 그룹핑, 하나 이상의 칼럼을 사용하여 그룹을 나누고, 그룹별로 다시 서브 구릅을 나눔
전체 교수를 학과별로 먼저 그룹핑한 다음, 학과별 교수를 직급별로 다시 그룹핑하는 경우

ROLLUP 연산자 


HAVING 절
-GROUP BY 절에 의해 생성된 그룹을 대상으로 조건을 적용

HAVING 절은 WHERE 절을 먼저 실행 한 후에 적용됨. 즉 추가 조건이라구 생각하면 됨.
정확한 위치는 GROUP BY 앞이 된다.

